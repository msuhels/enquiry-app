#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Creates directory structure and files based on the module configuration
 */
class FileStructureGenerator {
    constructor(configPath = './subzero.config.ts', outputDir = 'module-output') {
        this.configPath = configPath;
        this.outputDir = outputDir;
        this.baseDir = path.join(process.cwd(), outputDir);
    }

    /**
     * Reads and parses the TypeScript config file
     */
    async loadConfig() {
        try {
            // Read the config file
            const configContent = fs.readFileSync(this.configPath, 'utf8');
            
            // Simple parsing - extract the module object
            // This assumes the export format matches your example
            const moduleMatch = configContent.match(/export const module = ({[\s\S]*?});/);
            
            if (!moduleMatch) {
                throw new Error('Could not find module export in config file');
            }

            // Convert to valid JSON by replacing single quotes and handling trailing commas
            let jsonString = moduleMatch[1]
                .replace(/'/g, '"')  // Replace single quotes with double quotes
                .replace(/,(\s*[}\]])/g, '$1')  // Remove trailing commas
                .replace(/(\w+):/g, '"$1":');  // Quote unquoted keys

            return JSON.parse(jsonString);
        } catch (error) {
            console.error('Error loading config:', error.message);
            throw error;
        }
    }

    /**
     * Creates a directory if it doesn't exist
     */
    createDirectory(dirPath) {
        if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath, { recursive: true });
            console.log(`‚úÖ Created directory: ${dirPath}`);
            return true;
        }
        console.log(`üìÅ Directory already exists: ${dirPath}`);
        return false;
    }

    /**
     * Creates a file by copying content from source file if it doesn't exist
     */
    createFile(filePath, sourceFilePath) {
        if (!fs.existsSync(filePath)) {
            let content = '';

            // If source file path is provided, copy content from source
            if (sourceFilePath && fs.existsSync(sourceFilePath)) {
                content = fs.readFileSync(sourceFilePath, 'utf8');
                console.log(`üìÑ Copied content from: ${sourceFilePath}`);
            } else {
                // Fallback to basic content based on file type
                const ext = path.extname(filePath);
                switch (ext) {
                    case '.ts':
                    case '.tsx':
                        content = `// ${path.basename(filePath)}\n// Generated by SubZero Config\n\nexport {};\n`;
                        break;
                    case '.js':
                    case '.jsx':
                        content = `// ${path.basename(filePath)}\n// Generated by SubZero Config\n\nmodule.exports = {};\n`;
                        break;
                    default:
                        content = `/* ${path.basename(filePath)} */\n/* Generated by SubZero Config */\n`;
                }
                if (sourceFilePath) {
                    console.log(`‚ö†Ô∏è  Source file not found: ${sourceFilePath}, using template`);
                }
            }

            fs.writeFileSync(filePath, content);
            console.log(`üìÑ Created file: ${filePath}`);
            return true;
        }
        console.log(`üìÑ File already exists: ${filePath}`);
        return false;
    }

    /**
     * Collects SQL schemas from various sources
     */
    async collectSchemas() {
        const schemas = [];
        
        // Look for SQL files
        const sqlFiles = [
            'schema.sql',
            'database.sql',
            'auth.sql',
            'users.sql'
        ];
        
        for (const sqlFile of sqlFiles) {
            if (fs.existsSync(sqlFile)) {
                const content = fs.readFileSync(sqlFile, 'utf8').trim();
                if (content) {
                    schemas.push(content);
                }
            }
        }
        
        // Look for schema content in TypeScript files (for embedded SQL)
        const schemaFiles = [
            'lib/schema/auth-module/database.ts',
            'lib/database/schema.ts',
            'database/schema.ts'
        ];
        
        for (const schemaFile of schemaFiles) {
            if (fs.existsSync(schemaFile)) {
                const content = fs.readFileSync(schemaFile, 'utf8');
                // Extract SQL from template literals or comments
                const sqlMatches = content.match(/`([^`]*(?:CREATE|DROP|ALTER|INSERT)[^`]*)`/g);
                if (sqlMatches) {
                    sqlMatches.forEach(match => {
                        const sql = match.replace(/`/g, '').trim();
                        if (sql && sql.length > 10) {
                            schemas.push(sql);
                        }
                    });
                }
            }
        }
        
        // Default schema if no schemas found
        if (schemas.length === 0) {
            schemas.push(`-- Default Auth Module Database Schema
-- Users table for authentication
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT now() NOT NULL,
  updated_at TIMESTAMP DEFAULT now() NOT NULL
);

-- Create indexes for better performance
CREATE UNIQUE INDEX IF NOT EXISTS users_email_idx ON users(email);

-- Enable Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Create policies for user access
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE USING (auth.uid() = id);

-- Function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for updated_at
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();`);
        }
        
        return schemas.join('\n\n');
    }

    /**
     * Generates module-metadata.ts file based on the config
     */
    async generateModuleMetadata(config) {
        const moduleName = config.module;
        const metadataPath = path.join(this.baseDir, 'module-metadata.ts');
        
        // Convert config structure to ModuleMetadata format
        const files = [];
        
        for (const [folderPath, sourceFiles] of Object.entries(config)) {
            if (folderPath === 'module') continue;
            
            if (Array.isArray(sourceFiles)) {
                for (const sourceFilePath of sourceFiles) {
                    const fileName = path.basename(sourceFilePath);
                    const destinationPath = `src/${sourceFilePath}`;
                    const sourcePath = `src/${folderPath}/${fileName}`.replace('//', '/');
                    
                    // Determine file type based on path and extension
                    let fileType = 'util';
                    if (sourceFilePath.includes('/api/')) {
                        fileType = 'api';
                    } else if (sourceFilePath.endsWith('page.tsx')) {
                        fileType = 'page';
                    } else if (sourceFilePath.includes('components/')) {
                        fileType = 'component';
                    }
                    
                    files.push({
                        sourcePath,
                        destinationPath,
                        type: fileType
                    });
                }
            }
        }
        
        // Collect all schemas
        const allSchemas = await this.collectSchemas();
        
        const metadataContent = `import { ModuleMetadata } from ".";

export const ${moduleName.replace('-module', '').replace('-', '')}ModuleMetadata: ModuleMetadata = {
  name: '${moduleName.replace('-module', '')}',
  version: '0.1.0',
  description: 'Generated module with authentication and user management features',
  dependencies: [
    '@supabase/supabase-js',
    '@supabase/auth-helpers-nextjs',
    '@supabase/auth-helpers-react',
    'zustand'
  ],
  files: [
${files.map(file => `    // ${file.type.charAt(0).toUpperCase() + file.type.slice(1)}
    {
      sourcePath: '${file.sourcePath}',
      destinationPath: '${file.destinationPath}',
      type: '${file.type}'
    }`).join(',\n')}
  ],
  schemas: \`
${allSchemas}
  \`
};`;

        fs.writeFileSync(metadataPath, metadataContent);
        console.log(`üìÑ Created module metadata file: ${metadataPath}`);
    }

    /**
     * Processes the module configuration and creates files/directories
     */
    async generate() {
        try {
            console.log('üöÄ Starting file structure generation...\n');
            
            // Delete existing output directory if it exists
            if (fs.existsSync(this.baseDir)) {
                console.log(`üóëÔ∏è  Deleting existing directory: ${this.outputDir}`);
                fs.rmSync(this.baseDir, { recursive: true, force: true });
                console.log(`‚úÖ Deleted existing directory: ${this.outputDir}`);
            }
            
            // Create the output directory fresh
            console.log(`üìÅ Creating output directory: ${this.outputDir}`);
            this.createDirectory(this.baseDir);
            
            const config = await this.loadConfig();
            
            let stats = {
                directoriesCreated: 0,
                filesCreated: 0,
                directoriesExisted: 0,
                filesExisted: 0
            };

            // Skip the first "module" key and process the rest
            for (const [folderPath, files] of Object.entries(config)) {
                if (folderPath === 'module') continue;

                // Create the directory inside module-output
                const fullDirPath = path.join(this.baseDir, folderPath);
                if (this.createDirectory(fullDirPath)) {
                    stats.directoriesCreated++;
                } else {
                    stats.directoriesExisted++;
                }

                // Create files in the directory
                if (Array.isArray(files)) {
                    for (const sourceFilePath of files) {
                        // Extract just the filename from the source path
                        const fileName = path.basename(sourceFilePath);
                        // Place the file in the target directory we created
                        const targetFilePath = path.join(fullDirPath, fileName);
                        
                        // Pass the source file path to copy content from
                        if (this.createFile(targetFilePath, sourceFilePath)) {
                            stats.filesCreated++;
                        } else {
                            stats.filesExisted++;
                        }
                    }
                }
            }

            // Generate module metadata file
            await this.generateModuleMetadata(config);

            console.log('\n‚ú® Generation complete!\n');
            console.log(`üìÇ All files created in: ${this.outputDir}/`);
            console.log('üìä Summary:');
            console.log(`   Directories created: ${stats.directoriesCreated}`);
            console.log(`   Files created: ${stats.filesCreated + 1}`); // +1 for metadata file
            console.log(`   Directories already existed: ${stats.directoriesExisted}`);
            console.log(`   Files already existed: ${stats.filesExisted}`);

        } catch (error) {
            console.error('‚ùå Error during generation:', error.message);
            process.exit(1);
        }
    }
}

// CLI execution
if (require.main === module) {
    const args = process.argv.slice(2);
    const configPath = args[0] || './subzero.config.ts';
    const outputDir = args[1] || 'module-output';
    
    console.log(`üìñ Using config file: ${configPath}`);
    console.log(`üìÇ Output directory: ${outputDir}\n`);
    
    const generator = new FileStructureGenerator(configPath, outputDir);
    generator.generate();
}

module.exports = FileStructureGenerator;